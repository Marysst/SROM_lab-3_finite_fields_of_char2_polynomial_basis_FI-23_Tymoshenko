# Основний код (программа)
class GF2Field: 
    def __init__(self, m, irreducible_poly): 
        self.m = m 
        self.irreducible_poly = irreducible_poly 

    # Додавання двох елементів у полі 
    def add(self, a, b): 
        return a ^ b 

    # Множення двох елементів у полі 
    def multiply(self, a, b): 
        c = 0 
        t = a 
        for i in range(b.bit_length()): 
            if (b >> i) & 1: 
                c ^= t 
            t <<= 1 
        return self.mod(c) 

    # Редукція елемента за незвідним поліномом 
    def mod(self, c): 
        t = c 
        while t.bit_length() >= self.irreducible_poly.bit_length(): 
            shift = t.bit_length() - self.irreducible_poly.bit_length() 
            t ^= self.irreducible_poly << shift 
        return t 

    # Піднесення елемента поля до квадрату 
    def square(self, a): 
        return self.multiply(a, a) 

    # Піднесення елемента поля до довільного степеня 
    def power(self, a, n): 
        result = 1 
        base = a 
        while n > 0: 
            if n & 1: 
                result = self.multiply(result, base) 
            base = self.square(base) 
            n >>= 1 
        return result 

    # Знаходження оберненого елемента за множенням 
    def inverse(self, a): 
        # Використовуємо те, що a^(2^m - 2) = a^{-1} у GF(2^m) 
        return self.power(a, (1 << self.m) - 2) 

# Тестування
# Задаємо поле 
x_a, x_b, x_c, x_d = 491, 17, 6, 2 
irreducible_poly = (1 << x_a) | (1 << x_b) | (1 << x_c) | (1 << x_d) | 1 

field = GF2Field(x_a, irreducible_poly) 

# Елементи поля 
a = 0b10011001101000001011100111001011001001011000000011111111110101010111101100100000101000000110111111100011100100010111111101010010010101110000001111110101111110100011000011000000001101110110001110111001111111101010010000100101001001101000000000000010011010000100101010001011001000010000010111110011100010111111100101111100001111101111111101000111000011101110101111110001101000000110100010101010001001111101110010111101100100011011010101110111101011000001101100110000010001110101000110001111110 
b = 0b10000100001100110000101010111111100100100100101001110010011111111111111011100100111110100000010011011010000010100101111110000010001100101110001010001011011101100110000101011011011101010111010111100011011010010111111100000110110011010011100111111110000011110001011100100011110000010010101011000001001010110101001100101110011011111100001100111111011001101011111010110110100101101001111000111001000000100001100110010101000100011100011011111010010000111010111110100101111001110111100011000000110 
c = 0b01000001101000001111110110001100011110000111111010000100000111100011111011000001000000100110110000111100100011110101101111100111001011110100101001001000101100101100101000101000111101010010011110110111001010010000001011100100000100001101111010011000001010001010110111000111100110000100011101100100011010100011101111100010000101110110100100000011110011000001001100010000010000010101100010110001001010110011001101100101011100101101111111001100111010110000001010101111000111111101110100110000001 

# Тест1 (а+b)*c=a*c+b*c 
result_a_add_b = field.add(a, b) 
result_a_add_b_mult_c = field.multiply(result_a_add_b, c) 
result_a_mult_c = field.multiply(a, c) 
result_b_mult_c = field.multiply(b, c) 
result_a_mult_c_add_bmult_c = field.add(result_a_mult_c, result_b_mult_c) 

if result_a_add_b_mult_c == result_a_mult_c_add_bmult_c: 
    print("Умова виконується, тест пройдено") 
else: 
    print("Умова не виконується, тест провалено") 

# Тест2 с^(2^m-1)=1 
result_power = field.power(c, (1 << x_a) - 1) 

if result_power == 1: 
    print("Умова виконується, тест пройдено") 
else: 
    print("Умова не виконується, тест провалено") 
